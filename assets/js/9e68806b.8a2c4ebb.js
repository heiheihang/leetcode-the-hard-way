"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[7299],{3905:function(e,t,a){a.d(t,{Zo:function(){return l},kt:function(){return k}});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function m(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),o=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):m(m({},t),e)),a},l=function(e){var t=o(e.components);return n.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,p=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),d=o(a),k=r,u=d["".concat(p,".").concat(k)]||d[k]||c[k]||s;return a?n.createElement(u,m(m({ref:t},l),{},{components:a})):n.createElement(u,m({ref:t},l))}));function k(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,m=new Array(s);m[0]=d;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i.mdxType="string"==typeof e?e:r,m[1]=i;for(var o=2;o<s;o++)m[o]=a[o];return n.createElement.apply(null,m)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},88100:function(e,t,a){a.r(t),a.d(t,{assets:function(){return l},contentTitle:function(){return p},default:function(){return k},frontMatter:function(){return i},metadata:function(){return o},toc:function(){return c}});var n=a(87462),r=a(63366),s=(a(67294),a(3905)),m=["components"],i={description:"Author: @wingkwong | https://leetcode.com/problems/network-delay-time/"},p="0743 - Network Delay Time (Medium)",o={unversionedId:"0700-0799/network-delay-time-medium",id:"0700-0799/network-delay-time-medium",title:"0743 - Network Delay Time (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/network-delay-time/",source:"@site/solutions/0700-0799/0743-network-delay-time-medium.md",sourceDirName:"0700-0799",slug:"/0700-0799/network-delay-time-medium",permalink:"/leetcode-the-hard-way/solutions/0700-0799/network-delay-time-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/solutions/0700-0799/0743-network-delay-time-medium.md",tags:[],version:"current",sidebarPosition:743,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/network-delay-time/"},sidebar:"tutorialSidebar",previous:{title:"0740 - Delete and Earn (Medium)",permalink:"/leetcode-the-hard-way/solutions/0700-0799/delete-and-earn-medium"},next:{title:"0744 - Find Smallest Letter Greater Than Target (Easy)",permalink:"/leetcode-the-hard-way/solutions/0700-0799/find-smallest-letter-greater-than-target-easy"}},l={},c=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Dijkstra",id:"approach-1-dijkstra",level:2},{value:"Approach 2: Bellman Ford",id:"approach-2-bellman-ford",level:2}],d={toc:c};function k(e){var t=e.components,a=(0,r.Z)(e,m);return(0,s.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"0743---network-delay-time-medium"},"0743 - Network Delay Time (Medium)"),(0,s.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,s.kt)("p",null,"You are given a network of ",(0,s.kt)("inlineCode",{parentName:"p"},"n")," nodes, labeled from ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"n"),". You are also given ",(0,s.kt)("inlineCode",{parentName:"p"},"times"),", a list of travel times as directed edges ",(0,s.kt)("inlineCode",{parentName:"p"},"times[i] = (ui, vi, wi)"),", where ",(0,s.kt)("inlineCode",{parentName:"p"},"ui")," is the source node, ",(0,s.kt)("inlineCode",{parentName:"p"},"vi")," is the target node, and ",(0,s.kt)("inlineCode",{parentName:"p"},"wi")," is the time it takes for a signal to travel from source to target."),(0,s.kt)("p",null,"We will send a signal from a given node ",(0,s.kt)("inlineCode",{parentName:"p"},"k"),". Return the time it takes for all the ",(0,s.kt)("inlineCode",{parentName:"p"},"n")," nodes to receive the signal. If it is impossible for all the ",(0,s.kt)("inlineCode",{parentName:"p"},"n")," nodes to receive the signal, return ",(0,s.kt)("inlineCode",{parentName:"p"},"-1"),"."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example 1:")),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png",alt:null})),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\nOutput: 2\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example 2:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Input: times = [[1,2,1]], n = 2, k = 1\nOutput: 1\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example 3:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Input: times = [[1,2,1]], n = 2, k = 2\nOutput: -1\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Constraints:")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"1 <= k <= n <= 100")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"1 <= times.length <= 6000")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"times[i].length == 3")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"1 <= ui, vi <= n")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ui != vi")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"0 <= wi <= 100")),(0,s.kt)("li",{parentName:"ul"},"All the pairs ",(0,s.kt)("inlineCode",{parentName:"li"},"(ui, vi)")," are ",(0,s.kt)("strong",{parentName:"li"},"unique"),". (i.e., no multiple edges.)")),(0,s.kt)("h2",{id:"approach-1-dijkstra"},"Approach 1: Dijkstra"),(0,s.kt)("p",null,"If we know the time between the starting node and other nodes, then the answer would be the max time. In example 1, if node 2 goes to node 4, it takes 2 seconds. If node 2 goes to to node 1, it takes 1 second. If we take the max time, then other cases would be covered as well."),(0,s.kt)("p",null,"Therefore, the problem is now asking to find out the max time it takes from the starting node to an arbitrary node. To calculate the shortest path from node A to node B, we can use Dijkstra. Let ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"d"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"["),(0,s.kt)("mi",{parentName:"mrow"},"i"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"]")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"d[i]")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"d"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"["),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"i"),(0,s.kt)("span",{parentName:"span",className:"mclose"},"]")))))," be the time that is required to reach from the starting point to node ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"i")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"i")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6595em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"i"))))),". We initialise each time as ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mn",{parentName:"mrow"},"1"),(0,s.kt)("mi",{parentName:"mrow"},"e"),(0,s.kt)("mn",{parentName:"mrow"},"9")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"1e9")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"1"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"e"),(0,s.kt)("span",{parentName:"span",className:"mord"},"9"))))),". After calling dijkstra function, if there is one node that need ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"t"),(0,s.kt)("mi",{parentName:"mrow"},"i"),(0,s.kt)("mi",{parentName:"mrow"},"m"),(0,s.kt)("mi",{parentName:"mrow"},"e"),(0,s.kt)("mo",{parentName:"mrow"},"="),(0,s.kt)("mn",{parentName:"mrow"},"1"),(0,s.kt)("mi",{parentName:"mrow"},"e"),(0,s.kt)("mn",{parentName:"mrow"},"9")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"time = 1e9")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6595em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"im"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"e"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.kt)("span",{parentName:"span",className:"mrel"},"="),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"1"),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"e"),(0,s.kt)("span",{parentName:"span",className:"mord"},"9")))))," to reach, then it means this node is unreachable. We can return ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mo",{parentName:"mrow"},"\u2212"),(0,s.kt)("mn",{parentName:"mrow"},"1")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"-1")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"\u2212"),(0,s.kt)("span",{parentName:"span",className:"mord"},"1")))))," in this case. Otherwise, return the max one."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    template<typename T_pair, typename T_vector>\n    void dijkstra(T_pair &g, T_vector &dist, int start) {\n      priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n      dist[start] = 0;\n      pq.push({start, 0});\n      while (!pq.empty()) {\n        auto [u_node, u_cost] = pq.top(); pq.pop();\n        if (u_cost > dist[u_node]) continue;\n        for (auto [v_node, v_cost] : g[u_node]) {\n          if (dist[v_node] > dist[u_node] + v_cost) {\n            dist[v_node] = dist[u_node] + v_cost;\n            pq.push({v_node, dist[v_node]});\n          }\n        }\n      }\n    }\n\n    int networkDelayTime(vector<vector<int>>& times, int n, int k) {\n        vector<vector<pair<int, int>>> g(n + 1);\n        for (auto x : times) g[x[0]].push_back({x[1], x[2]});\n        vector<int> d(n + 1, 1e9);\n        dijkstra(g, d, k);\n        int ans = *max_element(d.begin() + 1, d.end());\n        return ans == 1e9 ? -1 : ans;\n    }\n};\n")),(0,s.kt)("h2",{id:"approach-2-bellman-ford"},"Approach 2: Bellman Ford"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    template<typename T_a3, typename T_vector>\n    void bellman_ford(T_a3 &g, T_vector &dist, int src, int mx_edges) {\n        // dist[i] : dist to reach node j using at most i edges from src\n        dist[src] = 0;\n        for (int i = 0; i <= mx_edges; i++) {\n            T_vector ndist = dist;\n            for (auto x : g) {\n                auto [from, to, cost] = x;\n                ndist[to] = min(ndist[to], dist[from] + cost);\n            }\n            dist = ndist;\n        }\n    }\n    \n    int networkDelayTime(vector<vector<int>>& times, int n, int k) {\n        vector<array<int, 3>> g;\n        vector<int> dist(n, 1e9);\n        for (auto x : times) g.push_back({x[0] - 1, x[1] - 1, x[2]});\n        bellman_ford(g, dist, k - 1, n);\n        int mx = *max_element(dist.begin(), dist.end());\n        return mx == 1e9 ? -1 : mx;\n    }\n};\n")))}k.isMDXComponent=!0}}]);