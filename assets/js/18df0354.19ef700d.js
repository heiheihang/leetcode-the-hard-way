"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[4648],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return h}});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),m=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=m(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),u=m(n),h=o,d=u["".concat(l,".").concat(h)]||u[h]||c[h]||r;return n?a.createElement(d,i(i({ref:t},s),{},{components:n})):a.createElement(d,i({ref:t},s))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p.mdxType="string"==typeof e?e:o,i[1]=p;for(var m=2;m<r;m++)i[m]=n[m];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},83011:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return p},metadata:function(){return m},toc:function(){return c}});var a=n(87462),o=n(63366),r=(n(67294),n(3905)),i=["components"],p={description:"Author: @wingkwong | https://leetcode.com/problems/boats-to-save-people/"},l="0881 - Boats to Save People (Medium)",m={unversionedId:"0800-0899/boats-to-save-people-medium",id:"0800-0899/boats-to-save-people-medium",title:"0881 - Boats to Save People (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/boats-to-save-people/",source:"@site/solutions/0800-0899/0881-boats-to-save-people-medium.md",sourceDirName:"0800-0899",slug:"/0800-0899/boats-to-save-people-medium",permalink:"/leetcode-the-hard-way/solutions/0800-0899/boats-to-save-people-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/solutions/0800-0899/0881-boats-to-save-people-medium.md",tags:[],version:"current",sidebarPosition:881,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/boats-to-save-people/"},sidebar:"tutorialSidebar",previous:{title:"0877 - Stone Game (Medium)",permalink:"/leetcode-the-hard-way/solutions/0800-0899/stone-game-medium"},next:{title:"0900 - 0999",permalink:"/leetcode-the-hard-way/solutions/category/0900---0999"}},s={},c=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Greedy",id:"approach-1-greedy",level:2}],u={toc:c};function h(e){var t=e.components,n=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"0881---boats-to-save-people-medium"},"0881 - Boats to Save People (Medium)"),(0,r.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.kt)("p",null,"You are given an array ",(0,r.kt)("inlineCode",{parentName:"p"},"people")," where ",(0,r.kt)("inlineCode",{parentName:"p"},"people[i]")," is the weight of the ",(0,r.kt)("inlineCode",{parentName:"p"},"ith")," person, and an ",(0,r.kt)("strong",{parentName:"p"},"infinite number of boats")," where each boat can carry a maximum weight of ",(0,r.kt)("inlineCode",{parentName:"p"},"limit"),". Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most ",(0,r.kt)("inlineCode",{parentName:"p"},"limit"),"."),(0,r.kt)("p",null,"Return ",(0,r.kt)("em",{parentName:"p"},"the minimum number of boats to carry every given person"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: people = [1,2], limit = 3\nOutput: 1\nExplanation: 1 boat (1, 2)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: people = [3,2,2,1], limit = 3\nOutput: 3\nExplanation: 3 boats (1, 2), (2) and (3)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 3:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: people = [3,5,3,4], limit = 5\nOutput: 4\nExplanation: 4 boats (3), (3), (4), (5)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Constraints:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"1 <= people.length <= 5 * 10^4")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"1 <= people[i] <= limit <= 3 * 10^4"))),(0,r.kt)("h2",{id:"approach-1-greedy"},"Approach 1: Greedy"),(0,r.kt)("p",null,"Let's sort the input. We know that the maximum weight is at most ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"l"),(0,r.kt)("mi",{parentName:"mrow"},"i"),(0,r.kt)("mi",{parentName:"mrow"},"m"),(0,r.kt)("mi",{parentName:"mrow"},"i"),(0,r.kt)("mi",{parentName:"mrow"},"t")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"limit")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.01968em"}},"l"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"imi"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"))))),". The best way to choose the maximum weight first. Then we check if we could include one more (the minimum one). We can use two pointers to track the minimum one and the maximum one."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int numRescueBoats(vector<int>& people, int limit) {\n        // sort the input so that we can use two pointers from both side\n        sort(people.begin(), people.end());\n        // init variables\n        int n = people.size(), ans = 0, i = 0, j = n - 1;\n        // do the following logic until both pointer meets each other\n        while (i <= j) {\n            // first we pick the maximum none\n            int pick = people[j];\n            // we check the remaining capacity\n            int left = limit - pick;\n            // if we can include the minimum one, then take it as well\n            if (people[i] <= left) {\n                // need one boat for i-th person and j-th person\n                ans++;\n                // increase both pointer\n                i++, j--;\n            } else {\n                // need one boat for the j-th person\n                ans++;\n                // move the max pointer\n                j--;\n            }\n        }\n        return ans;\n    }\n};\n")),(0,r.kt)("p",null,"Once we get the idea, we can further refactor the solution."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int numRescueBoats(vector<int>& people, int limit) {\n        sort(people.begin(), people.end());\n        int n = people.size(), ans = 0, i = 0, j = n - 1;\n        while (i <= j) {\n            // move the min pointer only i-th person is included \n            i += people[j] + people[i] <= limit;\n            // need one boat for each round\n            // move the max pointer as it is always chosen\n            ans++, j--;\n        }        \n        return ans;\n    }\n};\n")))}h.isMDXComponent=!0}}]);