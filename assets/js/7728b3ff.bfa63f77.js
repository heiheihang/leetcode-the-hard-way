"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[6809],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return k}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=s(n),k=r,d=u["".concat(p,".").concat(k)]||u[k]||c[k]||i;return n?a.createElement(d,l(l({ref:t},m),{},{components:n})):a.createElement(d,l({ref:t},m))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=u;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var s=2;s<i;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},81757:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return p},default:function(){return k},frontMatter:function(){return o},metadata:function(){return s},toc:function(){return c}});var a=n(87462),r=n(63366),i=(n(67294),n(3905)),l=["components"],o={description:"Author: @heiheihang | https://leetcode.com/problems/min-stack/"},p="0155 - Min Stack (Easy)",s={unversionedId:"0100-0199/min-stack-easy",id:"0100-0199/min-stack-easy",title:"0155 - Min Stack (Easy)",description:"Author: @heiheihang | https://leetcode.com/problems/min-stack/",source:"@site/solutions/0100-0199/0155-min-stack-easy.md",sourceDirName:"0100-0199",slug:"/0100-0199/min-stack-easy",permalink:"/leetcode-the-hard-way/solutions/0100-0199/min-stack-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/solutions/0100-0199/0155-min-stack-easy.md",tags:[],version:"current",sidebarPosition:155,frontMatter:{description:"Author: @heiheihang | https://leetcode.com/problems/min-stack/"},sidebar:"tutorialSidebar",previous:{title:"0148 - Sort List (Medium)",permalink:"/leetcode-the-hard-way/solutions/0100-0199/sort-list-medium"},next:{title:"0165 - Compare Version Numbers (Medium)",permalink:"/leetcode-the-hard-way/solutions/0100-0199/compare-version-numbers-medium"}},m={},c=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Implementation",id:"approach-1-implementation",level:2}],u={toc:c};function k(e){var t=e.components,n=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"0155---min-stack-easy"},"0155 - Min Stack (Easy)"),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"Design a stack that supports push, pop, top, and retrieving the minimum element in constant time."),(0,i.kt)("p",null,"Implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"MinStack")," class:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MinStack()")," initializes the stack object."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"void push(int val)")," pushes the element ",(0,i.kt)("inlineCode",{parentName:"li"},"val")," onto the stack."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"void pop()")," removes the element on the top of the stack."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"int top()")," gets the top element of the stack."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"int getMin()")," retrieves the minimum element in the stack.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input\n["MinStack","push","push","push","getMin","pop","top","getMin"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\nOutput\n[null,null,null,null,-3,null,0,-2]\n\nExplanation\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-2^31 <= val <= 2^31 - 1")),(0,i.kt)("li",{parentName:"ul"},"Methods ",(0,i.kt)("inlineCode",{parentName:"li"},"pop"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"top")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"getMin")," operations will always be called on ",(0,i.kt)("strong",{parentName:"li"},"non-empty")," stacks."),(0,i.kt)("li",{parentName:"ul"},"At most ",(0,i.kt)("inlineCode",{parentName:"li"},"3 * 104")," calls will be made to ",(0,i.kt)("inlineCode",{parentName:"li"},"push"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"pop"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"top"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"getMin"),".")),(0,i.kt)("h2",{id:"approach-1-implementation"},"Approach 1: Implementation"),(0,i.kt)("p",null,"The general approach is to keep track of the ",(0,i.kt)("inlineCode",{parentName:"p"},"current_min")," at each level of the stack."),(0,i.kt)("p",null,"When we add a new element to the stack, we need to check if the new element is smaller than ",(0,i.kt)("inlineCode",{parentName:"p"},"current_min"),". If yes, we need to update the value. We also need to attach a label of ",(0,i.kt)("inlineCode",{parentName:"p"},"current_min")," when we ",(0,i.kt)("inlineCode",{parentName:"p"},"push"),", so we can keep track of the smallest element ",(0,i.kt)("strong",{parentName:"p"},"BEFORE")," that entry."),(0,i.kt)("p",null,"Similarly, when we ",(0,i.kt)("inlineCode",{parentName:"p"},"pop")," an element from the stack, we need to update ",(0,i.kt)("inlineCode",{parentName:"p"},"current_min"),". A simple example is that the last element in the stack is the smallest. When we ",(0,i.kt)("inlineCode",{parentName:"p"},"pop")," that element, ",(0,i.kt)("inlineCode",{parentName:"p"},"current_min")," is still not updated. Hence, we need to set ",(0,i.kt)("inlineCode",{parentName:"p"},"current_min")," to the new last element's label."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"top")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"getMin")," are very straightforward implementations."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class MinStack:\n\n    def __init__(self):\n        \n        #initialize stack\n        self.stack = []\n        \n        #we need to have a label to keep track of the current smallest number\n        self.current_min = None\n        \n    def push(self, val: int) -> None:\n        \n        #update current_min if new value is smaller\n        if(self.current_min == None or val < self.current_min):\n            self.current_min = val\n        \n        #besides adding val, we also need to add current_min to keep track of current_min\n        self.stack.append([val, self.current_min])\n        \n\n    def pop(self) -> None:\n        \n        #remove last element\n        self.stack.pop()\n        \n        #update current_min after popping\n        if(self.stack):\n            self.current_min = self.stack[-1][1]\n        else:\n            self.current_min = None\n\n    def top(self) -> int:\n        \n        #if stack is not empty, return the last element's value (not label)\n        if(self.stack):\n            return self.stack[-1][0]\n\n    def getMin(self) -> int:\n        \n        #return current_min\n        if(self.stack):\n            return self.current_min\n\n")))}k.isMDXComponent=!0}}]);