"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[2651],{3905:function(e,n,t){t.d(n,{Zo:function(){return m},kt:function(){return g}});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function u(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=r.createContext({}),s=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},m=function(e){var n=s(e.components);return r.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,m=u(e,["components","mdxType","originalType","parentName"]),p=s(t),g=i,d=p["".concat(l,".").concat(g)]||p[g]||c[g]||o;return t?r.createElement(d,a(a({ref:n},m),{},{components:t})):r.createElement(d,a({ref:n},m))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,a=new Array(o);a[0]=p;var u={};for(var l in n)hasOwnProperty.call(n,l)&&(u[l]=n[l]);u.originalType=e,u.mdxType="string"==typeof e?e:i,a[1]=u;for(var s=2;s<o;s++)a[s]=t[s];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},9270:function(e,n,t){t.r(n),t.d(n,{assets:function(){return m},contentTitle:function(){return l},default:function(){return g},frontMatter:function(){return u},metadata:function(){return s},toc:function(){return c}});var r=t(7462),i=t(3366),o=(t(7294),t(3905)),a=["components"],u={description:"Author: @wingkwong"},l="Minimum Spanning Tree",s={unversionedId:"graph-theory/minimum-spanning-tree",id:"graph-theory/minimum-spanning-tree",title:"Minimum Spanning Tree",description:"Author: @wingkwong",source:"@site/tutorials/graph-theory/minimum-spanning-tree.md",sourceDirName:"graph-theory",slug:"/graph-theory/minimum-spanning-tree",permalink:"/leetcode-the-hard-way/tutorials/graph-theory/minimum-spanning-tree",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tutorials/graph-theory/minimum-spanning-tree.md",tags:[],version:"current",lastUpdatedBy:"Wing-Kam Wong",lastUpdatedAt:1652613881,formattedLastUpdatedAt:"5/15/2022",frontMatter:{description:"Author: @wingkwong"},sidebar:"tutorialSidebar",previous:{title:"Kruskal's Algorithm",permalink:"/leetcode-the-hard-way/tutorials/graph-theory/kruskals-algorithm"},next:{title:"Prim's Algorithm",permalink:"/leetcode-the-hard-way/tutorials/graph-theory/prims-algorithm"}},m={},c=[{value:"Kruskal&#39;s Algorithm",id:"kruskals-algorithm",level:3},{value:"C++ Implementation",id:"c-implementation",level:4},{value:"Suggested Problems",id:"suggested-problems",level:3}],p={toc:c};function g(e){var n=e.components,t=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"minimum-spanning-tree"},"Minimum Spanning Tree"),(0,o.kt)("p",null,"A minimum spanning tree is a subset of the edges of a connected undirected graph with the minimum possible total edge weight and it does not contain any cycles."),(0,o.kt)("h3",{id:"kruskals-algorithm"},"Kruskal's Algorithm"),(0,o.kt)("p",null,"We sort the edges based on the weights in ascending order. Then we iterate them one by one, and greedily pick edges which does not result in cycle with the previous edges."),(0,o.kt)("h4",{id:"c-implementation"},"C++ Implementation"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class dsu {\n public:\n  vector<int> root, rank;\n  int n;\n  int cnt;\n\n  dsu(int _n) : n(_n) {\n    root.resize(n);\n    rank.resize(n);\n    for(int i = 0; i < n; i++) {\n        root[i] = i;\n        rank[i] = 1;\n    }\n    cnt = n;\n  }\n\n  inline int getCount() { return cnt; }\n\n  inline int get(int x) { return (x == root[x] ? x : (root[x] = get(root[x]))); }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n        if (rank[x] > rank[y]) {\n            root[y] = x;\n        } else if (rank[x] < rank[y]) {\n            root[x] = y;\n        } else {\n            root[y] = x;\n            rank[x] += 1;\n        }\n        cnt--;\n      return true;\n    }\n    return false;\n  }\n};\n\nint mst(vector<vector<int>>& g) {\n    int n = (int) g.size();\n    vector<array<int, 3>> edges;\n    // g[i] = {from, to, weight}\n    for (auto x : g) edges.push_back({x[2], x[0], x[1]}); \n    sort(edges.begin(), edges.end());\n    dsu d(n + 1);\n    int minimum_weight = 0;\n    for (auto x : edges) {\n        if (d.unite(x[1], x[2])) {\n            minimum_weight += x[0];\n        }\n    }\n    return minimum_weight;\n}\n")),(0,o.kt)("h3",{id:"suggested-problems"},"Suggested Problems"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"../../solutions/1100-1199/connecting-cities-with-minimum-cost-medium"},"1135 - Connecting Cities With Minimum Cost (Medium)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"../../solutions/1100-1199/optimize-water-distribution-in-a-village-hard"},"1168 - Optimize Water Distribution in a Village (Hard)"))))}g.isMDXComponent=!0}}]);