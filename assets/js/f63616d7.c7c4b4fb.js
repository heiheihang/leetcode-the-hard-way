"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[255],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return d}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),m=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},l=function(e){var t=m(e.components);return a.createElement(o.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),h=m(n),d=r,u=h["".concat(o,".").concat(d)]||h[d]||c[d]||i;return n?a.createElement(u,s(s({ref:t},l),{},{components:n})):a.createElement(u,s({ref:t},l))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=h;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p.mdxType="string"==typeof e?e:r,s[1]=p;for(var m=2;m<i;m++)s[m]=n[m];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},14475:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return o},default:function(){return d},frontMatter:function(){return p},metadata:function(){return m},toc:function(){return c}});var a=n(87462),r=n(63366),i=(n(67294),n(3905)),s=["components"],p={description:"Author: @wingkwong | https://leetcode.com/problems/create-binary-tree-from-descriptions/"},o="2196 - Create Binary Tree From Descriptions (Medium)",m={unversionedId:"2100-2199/create-binary-tree-from-descriptions-medium",id:"2100-2199/create-binary-tree-from-descriptions-medium",title:"2196 - Create Binary Tree From Descriptions (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/create-binary-tree-from-descriptions/",source:"@site/solutions/2100-2199/2196-create-binary-tree-from-descriptions-medium.md",sourceDirName:"2100-2199",slug:"/2100-2199/create-binary-tree-from-descriptions-medium",permalink:"/leetcode-the-hard-way/solutions/2100-2199/create-binary-tree-from-descriptions-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/solutions/2100-2199/2196-create-binary-tree-from-descriptions-medium.md",tags:[],version:"current",sidebarPosition:2196,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/create-binary-tree-from-descriptions/"},sidebar:"tutorialSidebar",previous:{title:"2195 - Append K Integers With Minimal Sum (Medium)",permalink:"/leetcode-the-hard-way/solutions/2100-2199/append-k-integers-with-minimal-sum-medium"},next:{title:"2197 - Replace Non-Coprime Numbers in Array (Hard)",permalink:"/leetcode-the-hard-way/solutions/2100-2199/replace-non-coprime-numbers-in-array-hard"}},l={},c=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Hash Map",id:"approach-1-hash-map",level:2}],h={toc:c};function d(e){var t=e.components,n=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"2196---create-binary-tree-from-descriptions-medium"},"2196 - Create Binary Tree From Descriptions (Medium)"),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"You are given a 2D integer array ",(0,i.kt)("inlineCode",{parentName:"p"},"descriptions")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"descriptions[i] = [parent_i, child_i, isLeft_i]")," indicates that ",(0,i.kt)("inlineCode",{parentName:"p"},"parent_i")," is the ",(0,i.kt)("strong",{parentName:"p"},"parent")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"child_i")," in a ",(0,i.kt)("strong",{parentName:"p"},"binary")," tree of ",(0,i.kt)("strong",{parentName:"p"},"unique")," values. Furthermore,"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If ",(0,i.kt)("inlineCode",{parentName:"li"},"isLeft_i == 1"),", then ",(0,i.kt)("inlineCode",{parentName:"li"},"child_i")," is the left child of ",(0,i.kt)("inlineCode",{parentName:"li"},"parent_i"),"."),(0,i.kt)("li",{parentName:"ul"},"If ",(0,i.kt)("inlineCode",{parentName:"li"},"isLeft_i == 0"),", then ",(0,i.kt)("inlineCode",{parentName:"li"},"child_i")," is the right child of ",(0,i.kt)("inlineCode",{parentName:"li"},"parent_i"),".")),(0,i.kt)("p",null,"Construct the binary tree described by ",(0,i.kt)("inlineCode",{parentName:"p"},"descriptions")," and return ",(0,i.kt)("em",{parentName:"p"},"its ",(0,i.kt)("strong",{parentName:"em"},"root")),"."),(0,i.kt)("p",null,"The test cases will be generated such that the binary tree is ",(0,i.kt)("strong",{parentName:"p"},"valid"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2022/02/09/example1drawio.png",alt:null})),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]\nOutput: [50,20,80,15,17,19]\nExplanation: The root node is the node with value 50 since it has no parent.\nThe resulting binary tree is shown in the diagram.\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2022/02/09/example2drawio.png",alt:null})),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: descriptions = [[1,2,1],[2,3,0],[3,4,1]]\nOutput: [1,2,null,null,3,4]\nExplanation: The root node is the node with value 1 since it has no parent.\nThe resulting binary tree is shown in the diagram.\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= descriptions.length <= 10^4")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"descriptions[i].length == 3")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= parent_i, child_i <= 10^5")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0 <= isLeft_i <= 1")),(0,i.kt)("li",{parentName:"ul"},"The binary tree described by ",(0,i.kt)("inlineCode",{parentName:"li"},"descriptions")," is valid.")),(0,i.kt)("h2",{id:"approach-1-hash-map"},"Approach 1: Hash Map"),(0,i.kt)("p",null,"We use a hash map to store the TreeNode","*"," for the key ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"i")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"i")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6595em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"i")))))," and another hash map to store if this TreeNode","*"," has a parent."),(0,i.kt)("p",null,"We iterate the input to get the values of parent, child and isLeft. Then we check if the parent and the child are in the hash map. If not, we create a new TreeNode for it and store it in hash map."),(0,i.kt)("p",null,"If ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"i"),(0,i.kt)("mi",{parentName:"mrow"},"s"),(0,i.kt)("mi",{parentName:"mrow"},"L"),(0,i.kt)("mi",{parentName:"mrow"},"e"),(0,i.kt)("mi",{parentName:"mrow"},"f"),(0,i.kt)("mi",{parentName:"mrow"},"t")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"isLeft")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"i"),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"s"),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"L"),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"e"),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"t")))))," is ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mn",{parentName:"mrow"},"1")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"1")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"1"))))),", that means the child is the left child of parent. Else, the child is the right child of parent."),(0,i.kt)("p",null,"At the end, we find out the node without parent, return that TreeNode","*"," because that is the root."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {\n        unordered_map<int, TreeNode*> m;\n        unordered_map<TreeNode*, int> hasParent;\n        TreeNode* p = nullptr;\n        TreeNode* c = nullptr;\n        for (auto x : descriptions) {\n            int parent = x[0], child = x[1], isLeft = x[2];\n            // check if TreeNode* for parent is in hash map or not\n            if (m.count(parent)) {\n                // if so, store it in p\n                p = m[parent];\n            } else {\n                // if not, create a new one\n                p = new TreeNode(parent);\n                // and store it in hash map\n                m[parent] = p;\n            }\n            // check if TreeNode* for child is in hash map or not\n            if (m.count(child)) {\n                // if so, store it in c\n                c = m[child];\n            } else {\n                // if not, create a new one\n                c = new TreeNode(child);\n                // and store it in hash map\n                m[child] = c;\n            }\n            // if isLeft is 1, then this child is the left child of this parent\n            if (isLeft) p->left = c;\n            // else this child is the right child of this parent\n            else p->right = c;\n            // mark this child has a parent\n            hasParent[c] = 1;\n        }\n        // search for a TreeNode* without parent\n        for (auto x : m) {\n            // found -> return this TreeNode* as this is the root\n            if (!hasParent.count(x.second)) {\n                return m[x.first];\n            }\n        }\n        // never reach here\n        return nullptr;\n    }\n};\n")))}d.isMDXComponent=!0}}]);