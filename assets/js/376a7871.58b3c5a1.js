"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[4343],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return h}});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var i=n.createContext({}),p=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(i.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=p(a),h=r,d=u["".concat(i,".").concat(h)]||u[h]||c[h]||s;return a?n.createElement(d,l(l({ref:t},m),{},{components:a})):n.createElement(d,l({ref:t},m))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,l=new Array(s);l[0]=u;var o={};for(var i in t)hasOwnProperty.call(t,i)&&(o[i]=t[i]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var p=2;p<s;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},59471:function(e,t,a){a.r(t),a.d(t,{assets:function(){return m},contentTitle:function(){return i},default:function(){return h},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return c}});var n=a(87462),r=a(63366),s=(a(67294),a(3905)),l=["components"],o={description:"Author: @SkollRyu | https://leetcode.com/problems/balanced-binary-tree/"},i="0110 - Balanced Binary Tree (Easy)",p={unversionedId:"0100-0199/balanced-binary-tree-easy",id:"0100-0199/balanced-binary-tree-easy",title:"0110 - Balanced Binary Tree (Easy)",description:"Author: @SkollRyu | https://leetcode.com/problems/balanced-binary-tree/",source:"@site/solutions/0100-0199/0110-balanced-binary-tree-easy.md",sourceDirName:"0100-0199",slug:"/0100-0199/balanced-binary-tree-easy",permalink:"/leetcode-the-hard-way/solutions/0100-0199/balanced-binary-tree-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/solutions/0100-0199/0110-balanced-binary-tree-easy.md",tags:[],version:"current",sidebarPosition:110,frontMatter:{description:"Author: @SkollRyu | https://leetcode.com/problems/balanced-binary-tree/"},sidebar:"tutorialSidebar",previous:{title:"0104 - Maximum Depth of Binary Tree (Easy)",permalink:"/leetcode-the-hard-way/solutions/0100-0199/maximum-depth-of-binary-tree-easy"},next:{title:"0115 - Distinct Subsequences (Hard)",permalink:"/leetcode-the-hard-way/solutions/0100-0199/distinct-subsequences-hard"}},m={},c=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Visualization",id:"visualization",level:2},{value:"Approach 1: Straight forward",id:"approach-1-straight-forward",level:2},{value:"Java",id:"java",level:3}],u={toc:c};function h(e){var t=e.components,a=(0,r.Z)(e,l);return(0,s.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"0110---balanced-binary-tree-easy"},"0110 - Balanced Binary Tree (Easy)"),(0,s.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,s.kt)("p",null,"Given a binary tree, determine if it is height-balanced."),(0,s.kt)("p",null,"For this problem, a height-balanced binary tree is defined as:"),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"a binary tree in which the left and right subtrees of ",(0,s.kt)("em",{parentName:"p"},"every")," node differ in height by no more than 1.")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example 1:")),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg",alt:null})),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Input: root = [3,9,20,null,null,15,7]\nOutput: true\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example 2:")),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg",alt:null})),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Input: root = [1,2,2,3,3,null,null,4,4]\nOutput: false\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example 3:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Input: root = []\nOutput: true \n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Constraints:")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"The number of nodes in the tree is in the range ",(0,s.kt)("inlineCode",{parentName:"li"},"[0, 5000]"),"."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"-10^4 <= Node.val <= 10^4"))),(0,s.kt)("h2",{id:"visualization"},"Visualization"),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/63882653/152684367-0ea099bd-623c-4d5a-8862-0ec035620c13.jpg",alt:"height-balanced"}),"\n",(0,s.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/63882653/152684944-1e774af3-8303-42be-9d7b-20af26221f74.jpg",alt:"Height-unbalanced"})),(0,s.kt)("h2",{id:"approach-1-straight-forward"},"Approach 1: Straight forward"),(0,s.kt)("p",null,"This solution is strictly following the definition of a balanced binary tree.",(0,s.kt)("br",{parentName:"p"}),"\n","(1) ABS(left sub-tree's height - right sub-tree's height) <= 1.",(0,s.kt)("br",{parentName:"p"}),"\n","(2) Every left sub-trees and right sub-trees are also balanced.  "),(0,s.kt)("p",null,"First, we need to set up the base case for the recursion solution. Then we check if the whole left subtree and right subtree are balanced. If so, then we check if every subtrees are balanced. This solution should give ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("msup",{parentName:"mrow"},(0,s.kt)("mi",{parentName:"msup"},"n"),(0,s.kt)("mn",{parentName:"msup"},"2")),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n^2)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,s.kt)("span",{parentName:"span",className:"msupsub"},(0,s.kt)("span",{parentName:"span",className:"vlist-t"},(0,s.kt)("span",{parentName:"span",className:"vlist-r"},(0,s.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,s.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,s.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))),(0,s.kt)("span",{parentName:"span",className:"mclose"},")")))))," time complexity"),(0,s.kt)("h3",{id:"java"},"Java"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public boolean isBalanced(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        if(Math.abs(height(root.left) - height(root.right)) <= 1){\n            return isBalanced(root.left) && isBalanced(root.right);\n        } else {\n            return false;\n        }\n    }\n    \n    public int height(TreeNode root){\n        if (root == null) return -1;\n        int ld = height(root.left);\n        int rd = height(root.right);\n        return 1 + Math.max(ld,rd);\n    }\n}\n")))}h.isMDXComponent=!0}}]);